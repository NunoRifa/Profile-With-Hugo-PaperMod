[{"content":"Ringkasan Artikel ini merupakan sharing ilmu pribadi saya tentang bagaimana cara membuat dan mendokumentasikan Google Custom Search Engine (CSE) Dorking Tool menggunakan bahasa Python.\nTool ini berfungsi untuk mencari URL potensial berdasarkan pola dork tertentu melalui API resmi Google, memeriksa status HTTP tiap hasil, dan menyimpan output-nya dalam format teks dan JSON.\nTujuan saya menulis ini bukan untuk mendorong eksploitasi, melainkan untuk memperkenalkan bagaimana konsep reconnaissance automation bekerja dengan API publik, threading, dan parsing hasil pencarian.\nCatatan: Artikel ini untuk tujuan pembelajaran dan eksplorasi teknis. Jangan gunakan untuk menyerang, mengeksploitasi, atau mengakses sistem tanpa izin.\nApa yang akan Anda pelajari Struktur sederhana sebuah tool dorking berbasis Python. Cara menggunakan Google Custom Search API (CSE) untuk query otomatis. Proses pemeriksaan status HTTP secara paralel menggunakan ThreadPoolExecutor. Menyimpan hasil scanning ke file .txt dan .json. Cara membuat installer script sederhana agar tool mudah dijalankan di terminal. Praktik aman, etika, dan batas penggunaan API saat melakukan eksperimen. Persiapan \u0026amp; Persyaratan Pastikan Anda memiliki:\nPython 3.8+ Pip (package manager bawaan Python) Koneksi internet Google API Key dan CSE CX ID\n(dapat dibuat di Google Custom Search Engine) Terminal / Command Line Struktur proyek Berikut struktur folder yang saya gunakan:\ngoogle-cse-dorktool/ ├── dork_tool.py # Script utama tool dorking ├── install_dork_tool.sh # Script instalasi dan symlink CLI └── README.md # Dokumentasi dan panduan penggunaan Penjelasan singkat dork_tool.py → berisi logika utama (Google CSE request, parallel check, output formatter). install_dork_tool.sh → script opsional untuk instalasi cepat ke sistem. README.md → dokumentasi tool dan contoh penggunaan CLI. Contoh isi .env (opsional) Jika Anda ingin menyembunyikan API key dari kode sumber, buat file .env di root proyek seperti berikut:\nGOOGLE_API_KEY=\u0026#34;YOUR_GOOGLE_API_KEY\u0026#34; CSE_CX=\u0026#34;YOUR_CUSTOM_SEARCH_ENGINE_CX\u0026#34; Kemudian, Anda bisa membaca variabel ini di dork_tool.py dengan:\nimport os GOOGLE_API_KEY = os.getenv(\u0026#34;GOOGLE_API_KEY\u0026#34;) CSE_CX = os.getenv(\u0026#34;CSE_CX\u0026#34;) Potongan kode penting dari dork_tool.py Agar tidak terlalu panjang, saya tampilkan hanya bagian inti untuk pembelajaran:\n# Bagian inisialisasi dan request API CSE def google_cse_search(query, api_key, cse_cx, num_results=10): url = f\u0026#34;https://www.googleapis.com/customsearch/v1?q={query}\u0026amp;key={api_key}\u0026amp;cx={cse_cx}\u0026#34; response = requests.get(url) data = response.json() return [item[\u0026#34;link\u0026#34;] for item in data.get(\u0026#34;items\u0026#34;, [])] # Pemeriksaan status halaman secara paralel def check_status(url): try: r = requests.get(url, timeout=8, verify=False) return (url, r.status_code, len(r.content)) except Exception: return (url, None, 0) Potongan di atas sudah cukup untuk memahami flow dasar: ambil URL dari CSE, lalu cek responnya\nCara instalasi (menggunakan install_dork_tool.sh) File install_dork_tool.sh saya letakkan di root repository. Isinya membantu Anda menginstal dependency dan menambahkan symlink ke sistem agar bisa menjalankan tool langsung lewat terminal.\n#!/bin/bash # install_dork_tool.sh pip3 install --user requests beautifulsoup4 urllib3 chmod +x dork_tool.py sudo ln -sf $(pwd)/dork_tool.py /usr/local/bin/dorktool echo \u0026#34;Instalasi selesai. Jalankan: dorktool --help\u0026#34; Untuk menginstal:\nchmod +x install_dork_tool.sh ./install_dork_tool.sh Cara penggunaan (CLI) Setelah instalasi, Anda bisa menjalankan tool ini dengan berbagai argumen:\n# Menampilkan bantuan dorktool --help # Contoh mencari parameter ?id= di seluruh domain dorktool -u \u0026#34;?id=\u0026#34; -n 20 --google-api-key \u0026#34;YOUR_KEY\u0026#34; --cse-cx \u0026#34;YOUR_CX\u0026#34; # Contoh dengan domain spesifik dan output file dorktool -d \u0026#34;example.com\u0026#34; -u \u0026#34;?page=\u0026#34; -s 200 301 -n 50 -o result.txt --json Penjelasan singkat argumen:\n-d atau --domain → filter domain target -u atau --url-pattern → pola dork (?id=, ?page=, dsb.) -s → status code filter -n → jumlah hasil pencarian -o → output file --google-api-key \u0026amp; --cse-cx → kredensial API CSE Contoh hasil output Hasil IMG: Hasil TXT:\nURL: https://target.example/?id=123 Status Code: 200 Title: Example Page Content Length: 3245 bytes Final URL: https://target.example/?id=123 -------------------------------------------------- Keamanan \u0026amp; Etika Bagian ini sangat penting, saya tekankan kembali untuk pembaca:\nGunakan tool ini hanya pada sistem yang Anda miliki atau dengan izin tertulis. Jangan menyimpan API key di repo publik. Jangan mematikan SSL verification di lingkungan produksi. Tambahkan rate limit / delay agar tidak mengirim terlalu banyak request ke server target. Hargai kebijakan robots.txt setiap situs. Gunakan hasil pencarian hanya untuk pembelajaran, riset keamanan, atau uji internal. Disclaimer: Semua contoh dan kode pada artikel ini bersifat edukatif. Penulis tidak bertanggung jawab atas penyalahgunaan kode di luar konteks pembelajaran.\nPotensi pengembangan Bagi pembaca yang ingin melanjutkan eksperimen:\nMenambahkan fallback ke DuckDuckGo / Bing jika Google API limit tercapai. Menyimpan hasil scan ke database (mis. SQLite atau MongoDB). Menambahkan proxy rotation atau user-agent rotation otomatis. Mengimplementasikan rate limit berbasis domain. Menambahkan GUI sederhana (mis. tkinter / streamlit). Penutup Proyek ini saya tulis sebagai bentuk sharing ilmu mengenai teknik dorking automation secara legal dan etis. Diharapkan pembaca dapat memahami bagaimana integrasi API, threading, dan pengolahan hasil dilakukan di Python.\nJika Anda ingin mencoba atau berkontribusi, seluruh source code bisa dilihat di: Repository: github\n","permalink":"https://nunorifa.netlify.app/posts/google-cse-dorking-tool-web-surface-scanner/","summary":"Panduan praktis langkah-demi-langkah membangun dan menjalankan tool dorking berbasis Google Custom Search API. Pembaca akan belajar cara mengumpulkan URL dari CSE, memeriksa respons secara paralel, menyimpan hasil, serta menerapkan konfigurasi dan langkah keamanan untuk eksperimen yang bertanggung jawab.","title":"Google CSE Dorking Tool - Web Surface Scanner"},{"content":"Pendahuluan Menyiapkan workstation untuk penetration testing membutuhkan beberapa komponen inti: hypervisor/virtualizer yang stabil, image target yang realistis (mis. Windows), serta mesin serangan yang berisi tool pentest (mis. Kali Linux). Dokumen ini menyajikan tautan unduhan untuk beberapa komponen yang umum dipakai dalam lab pentesting pribadi—ditujukan untuk mempercepat setup lab uji tanpa harus mengonfigurasi semuanya dari nol.\nCatatan penting: semua berkas dan image yang dibagikan di sini digunakan untuk tujuan pembelajaran dan pengujian pada lingkungan yang Anda miliki izin untuk menguji. Jangan gunakan image atau tools ini untuk aktivitas ilegal. Selalu pastikan Anda memiliki persetujuan eksplisit sebelum melakukan pengujian terhadap sistem pihak ketiga.\nDownload: VMware Workstation 17.5.2 (Windows x86-64) VMware Workstation adalah aplikasi virtualisasi yang memungkinkan menjalankan beberapa sistem operasi tamu (guest OS) di dalam satu host. Untuk keperluan pentesting, Workstation berguna untuk mengisolasi target dan environment serangan sehingga tidak mengganggu host utama.\nSumber unduhan:\nDownload dari ln5.sync.com - link 1 Download dari drive.google.com - link 2 Tips: setelah mengunduh, verifikasi checksum (jika tersedia) dan jalankan file di lingkungan terisolasi bila Anda ragu terhadap integritas berkas.\nDownload: Windows MSEdge–Win10 (VM image) Image Windows MSEdge–Win10 adalah mesin virtual Windows yang sudah dikonfigurasi cocok untuk mensimulasikan target Windows asli. Image prebuilt mempercepat pengujian exploit, kompatibilitas, maupun analisis forensik tanpa perlu memasang OS dari awal.\nSumber unduhan:\nDownload dari ln5.sync.com - link 1 Download dari drive.google.com - link 2 Perhatian: Pastikan lisensi dan ketentuan penggunaan image tersebut sesuai. Untuk pengujian yang lebih aman dan terjamin update, pertimbangkan menggunakan image resmi Microsoft yang disediakan untuk pengembang/pengetesan.\nDownload: Metasploitable (Lab Target Rentan) Metasploitable adalah VM yang sengaja dirancang rentan untuk keperluan latihan. Sangat cocok untuk belajar exploitasi, konfigurasi Metasploit, serta menguji teknik hardening setelah eksploitasi.\nSumber unduhan:\nDownload dari sourceforge.net- link 1 Catatan: gunakan Metasploitable hanya di jaringan terisolasi. Jangan sambungkan VM rentan ke jaringan produksi.\n(Opsional) Kali Linux - versi custom dari ZSecurity Kali Linux adalah distribusi standar untuk penetration testing, berisi banyak alat populer (nmap, Metasploit, John, dll.). Ada versi yang dimodifikasi oleh pihak ketiga seperti ZSecurity yang menyediakan image dengan konfigurasi dan paket tambahan untuk kemudahan setup.\nSumber unduhan:\nDownload Kali Linux Patched ZSecurity Rekomendasi: bila Anda mengutamakan keamanan dan update, gunakan versi resmi Kali dari kali.org. Gunakan image custom hanya jika Anda mempercayai sumber dan memahami perubahan yang dilakukan.\nPenutup Dokumen ini dirancang untuk membantu Anda mempercepat pembuatan lab pentest, mulai dari hypervisor (VMware Workstation), image target Windows, hingga mesin latihan rentan (Metasploitable) dan opsi Kali Linux. Gunakan tautan dengan bijak, dan selalu prioritaskan keamanan serta etika dalam setiap pengujian.\n","permalink":"https://nunorifa.netlify.app/posts/setup-tools-penetration-testing/","summary":"Dokumen ini adalah panduan praktis untuk menyiapkan workstation pentesting. Pembaca diberikan dua sumber unduhan untuk VMware Workstation 17.5.2 (link Sync dan Google Drive) dan dua sumber untuk image Windows MSEdge–Win10 yang siap dipakai pada VMware. Sebagai tambahan terdapat opsi untuk mengunduh Kali Linux yang telah dimodifikasi dari ZSecurity.","title":"Setup Tools Penetration Testing"},{"content":"Ringkasan Artikel ini menjelaskan cara membuat server sederhana menggunakan Golang yang menampilkan halaman landing sementara, meminta izin kamera dari pengguna (depan / belakang), menangkap foto, mengirim foto (base64 → bytes) dan data lokasi (diperoleh dari IP publik) ke Telegram. Setelah pengiriman selesai, pengguna diarahkan ke URL tujuan yang awalnya diberikan melalui query parameter ?url=.\nCatatan: artikel ini untuk tujuan pembelajaran / eksperimen. Jangan gunakan untuk melanggar privasi atau hukum.\nSource code: github\nApa yang akan Anda pelajari Struktur aplikasi backend Golang yang melayani HTML + JavaScript. Cara meminta akses kamera di browser, menangkap gambar, dan mengirimkannya sebagai JSON. Mengubah data data:image/jpeg;base64,... menjadi byte di server Go. Mengambil IP publik dan melakukan lookup lokasi menggunakan IP2Location API. Mengirim pesan dan foto ke Telegram melalui Bot API. Contoh konfigurasi .env untuk menyimpan token rahasia. Persiapan \u0026amp; Persyaratan Pastikan Anda memiliki:\nGo (disarankan 1.18+) Koneksi internet Akun Telegram + Bot (token dari BotFather) API key IP2Location Editor teks / terminal Struktur proyek (sederhana) camera-capture-server/ ├── main.go ├── .env └── README.md Contoh isi .env botToken = \u0026#34;YOUR_BOT_TOKEN\u0026#34; chatID = \u0026#34;YOUT_BOT_CHAT_ID\u0026#34; ip2LocationToken = \u0026#34;YOUR_API_IP2LOCATION\u0026#34; botToken = token Bot Telegram chatID = ID chat (user atau grup) tujuan pesan ip2LocationToken = API key IP2Location Potongan arsitektur \u0026amp; alur kerja singkat Pengguna mengunjungi: http://localhost:8080/?url=https://example.com Server menyajikan halaman HTML yang menjalankan JavaScript: Meminta izin kamera (mencoba front lalu back). Mengambil snapshot ke canvas → toDataURL('image/jpeg', 0.8). Mengirim JSON POST ke /upload-photo berisi: image, userId, urlId, camera, message. Server Go menerima JSON: Mengambil IP publik dengan https://api.ipify.org/?format=json. Memanggil IP2Location: https://api.ip2location.io/?key=TOKEN\u0026amp;ip=IP. Men-decode base64 image menjadi []byte. Menyusun pesan teks berisi IP, lokasi, Google Maps link, dan info ASN. Mengirim pesan teks dan foto ke Telegram via sendMessageToTelegram \u0026amp; sendPhotoToTelegram. Setelah selesai, browser diarahkan ke URL tujuan (url query param). Contoh payload JSON dari browser { \u0026#34;image\u0026#34;: \u0026#34;data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD...\u0026#34;, \u0026#34;userId\u0026#34;: \u0026#34;123456789\u0026#34;, \u0026#34;urlId\u0026#34;: \u0026#34;https://example.com\u0026#34;, \u0026#34;camera\u0026#34;: \u0026#34;front\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Foto berhasil diambil.\u0026#34; } Keamanan \u0026amp; Etika Jangan jalankan server ini dalam lingkungan produksi tanpa penambahan kontrol akses, enkripsi transport (HTTPS), dan kebijakan privasi yang jelas. Selalu minta izin eksplisit dari pengguna sebelum mengakses kamera. Batasi penggunaan data, simpanan, dan akses bot Telegram agar tidak bocor. Gunakan hanya untuk eksperimen yang legal dan etis. Contoh pesan yang dikirim ke Telegram Pesan teks yang dikirim berisi:\nIP publik URL asal (From URL) URL host (link yang mengarah kembali ke server dengan query ?url=...) Info lokasi: country, region, city, latitude, longitude Link Google Maps untuk koordinat AS/ISP, dan flag Is Proxy Contoh format (tekstual):\nIP Address : 103.123.45.67 From URL : https://example.com URL Host : http://yourserver.com/?url=https://example.com Location Country Code: ID Country Name: Indonesia Region Name : Jawa Timur City Name : Surabaya Latitude : -7.2575 Longitude : 112.7521 Maps : https://www.google.co.id/maps/place/-7.2575,112.7521 Network AS/ISP : PT Telkom Indonesia Is Proxy : false Foto akan diunggah sebagai file user_photo.jpg ke chat Telegram tujuan.\nPotensi perbaikan \u0026amp; fitur lanjutan Tambahkan HTTPS (TLS) agar komunikasi aman. Buat autentikasi / token validasi untuk endpoint /upload-photo agar tidak sembarang pihak bisa POST. Simpan foto ke cloud storage (S3, GCS) atau database dengan retention policy. Batasi resolusi dan ukuran upload untuk efisiensi. Tampilkan fallback dan pemberitahuan bila kamera tidak tersedia. Penutup Proyek ini merupakan contoh praktis integrasi frontend-browser (akses kamera) dengan backend Golang serta layanan pihak ketiga (IP2Location dan Telegram Bot). Cocok sebagai eksperimen untuk memahami alur data (media + metadata) dari klien ke server dan integrasi API.\n","permalink":"https://nunorifa.netlify.app/posts/membangun-server-capture-kamera-dan-redirect-otomatis-menggunakan-golang/","summary":"Langkah demi langkah membuat server Golang yang mengambil foto pengguna lewat browser, mengonversi gambar base64, mengambil IP publik \u0026amp; lokasi via IP2Location, lalu mengirimkan foto dan data lokasi ke Telegram Bot. Termasuk contoh konfigurasi .env dan instruksi menjalankan server.","title":"Membangun Server Capture Kamera dan Redirect Otomatis Menggunakan Golang"},{"content":"Ringkasan Artikel ini membahas pembuatan Samarinda Token Generator, sebuah script Python yang secara otomatis mengambil token dari situs https://generatetoken.my.id/samarinda/.\nTool ini bekerja dengan mengirimkan HWID (Hardware ID) ke server menggunakan metode POST, lalu mengekstrak token hasil dari respon HTML menggunakan regex, tanpa perlu membuka browser.\nSource code: github\nApa yang akan Anda pelajari Cara membuat script otomatisasi HTTP POST dengan Python. Penggunaan library requests dan urllib3 untuk komunikasi web. Teknik regex parsing untuk mengekstrak data dari HTML. Menyalin hasil token langsung ke clipboard menggunakan pyperclip. Penanganan error jaringan dengan try-except. Persiapan \u0026amp; Persyaratan Pastikan Anda sudah menyiapkan:\nPython 3.x Modul berikut: pip install requests urllib3 pyperclip Koneksi internet aktif HWID valid (32 karakter hex) Struktur proyek samarinda-token-generator/ ├── NewKeyGen.py └── README.md Penjelasan Alur Program Input HWID Pengguna diminta memasukkan HWID (32 karakter hex) melalui input terminal. hwid = input(\u0026#34;Masukkan Licensed Key (hex 32 karakter): \u0026#34;).strip() Kirim Request POST Script membuat sesi HTTP dan mengirim permintaan POST ke: https://generatetoken.my.id/samarinda/ dengan payload:\ndata = {\u0026#39;hwid\u0026#39;: hwid, \u0026#39;generate_token\u0026#39;: \u0026#39;\u0026#39;} Parsing Token Respon HTML dari server mengandung potongan teks: html: \u0026#34;\u0026lt;p id=\u0026#39;generated-token\u0026#39;\u0026gt;SMD-OL1HRD7JB2\u0026lt;/p\u0026gt;\u0026#34; Token diekstrak menggunakan regex:\nmatch = re.search(r\u0026#34;html:\\s*\\\u0026#34;\u0026lt;p id=\u0026#39;generated-token\u0026#39;\u0026gt;(.*?)\u0026lt;/p\u0026gt;\\\u0026#34;\u0026#34;, response.text) Salin ke Clipboard Jika token ditemukan, hasil langsung disalin ke clipboard: pyperclip.copy(token) print(\u0026#34;Token telah disalin ke clipboard.\u0026#34;) Penanganan Error Jika server gagal diakses, script akan menampilkan pesan error dari requests.exceptions.RequestException. Contoh Output Terminal Masukkan Licensed Key (hex 32 karakter): AE9EEB8ACEBAC3808006F786543210AJ ==== Mencari token ==== Token ditemukan: SMD-OL1HRD7JB2 Token telah disalin ke clipboard. Tekan sembarang tombol untuk keluar... Cuplikan Kode Utama match = re.search(r\u0026#34;html:\\s*\\\u0026#34;\u0026lt;p id=\u0026#39;generated-token\u0026#39;\u0026gt;(.*?)\u0026lt;/p\u0026gt;\\\u0026#34;\u0026#34;, response.text) if match: token = match.group(1) print(\u0026#34;Token ditemukan:\u0026#34;, token) return token else: print(\u0026#34;Token tidak ditemukan.\u0026#34;) Catatan Teknis Script ini tidak menggunakan Selenium atau JavaScript engine - cukup dengan parsing teks HTML dari respon. Header request diatur sedemikian rupa agar menyerupai browser sungguhan. Penggunaan verify=False menonaktifkan verifikasi SSL untuk mencegah error pada situs self-signed (tidak disarankan untuk produksi). Dapat dijalankan langsung di terminal Windows (menggunakan msvcrt.getch() untuk menunggu tombol keluar). Keamanan \u0026amp; Etika Jangan gunakan script ini untuk melakukan scraping atau request berulang yang dapat membebani server target. Gunakan hanya untuk eksperimen dan pembelajaran. Hindari menyebarkan token yang dihasilkan tanpa izin. Pastikan Anda memahami batas etika dan hukum dalam mengakses sistem pihak lain. Penutup Proyek ini adalah contoh praktis bagaimana Python dapat digunakan untuk mengotomatiskan interaksi web sederhana - dari mengirim form, membaca respon HTML, hingga menyalin hasil ke clipboard. Cocok untuk mempelajari dasar komunikasi client-server, parsing HTML ringan, dan struktur script utilitas berbasis CLI.\n","permalink":"https://nunorifa.netlify.app/posts/membangun-samarinda-token-generator-menggunakan-python/","summary":"Panduan membuat tool sederhana di Python yang mengirim permintaan POST ke server, memproses respon HTML yang berisi token, lalu menyalin hasil token ke clipboard. Cocok untuk pembelajaran automasi request–response dan parsing data dari web.","title":"Membangun Samarinda Token Generator Menggunakan Python"},{"content":"Saya seorang Web Developer yang memiliki ketertarikan pada dunia sistem, dan keamanan siber.\nSelama beberapa tahun terakhir, saya membangun aplikasi berbasis web menggunakan C#, ASP.NET, Svelte, dan Laravel, serta mengelola database MySQL dan SQL Server untuk memastikan performa sistem yang stabil, cepat, dan efisien.\nFokus \u0026amp; Keahlian\nSaya senang memadukan antara pengembangan dan keamanan sistem. Bagi saya, aplikasi yang baik bukan hanya berfungsi dengan benar, tetapi juga aman, terukur, dan mudah dipelihara.\nBeberapa bidang yang saya kuasai:\nPengembangan aplikasi web (Frontend \u0026amp; Backend) Optimasi query Automasi dan scripting Dasar-dasar keamanan siber dan penetration testing Perjalanan Saat Ini\nSaat ini, saya sedang mendalami bidang Cybersecurity dan Penetration Testing untuk memperluas wawasan saya di dunia keamanan informasi.\nTujuan saya adalah bertransisi menjadi seorang Cybersecurity Specialist atau Pentester yang mampu melihat sistem tidak hanya dari sisi pengembang, tetapi juga dari sisi keamanan.\n","permalink":"https://nunorifa.netlify.app/about/","summary":"\u003cp\u003eSaya seorang Web Developer yang memiliki ketertarikan pada dunia sistem, dan keamanan siber.\u003c/p\u003e\n\u003cp\u003eSelama beberapa tahun terakhir, saya membangun aplikasi berbasis web menggunakan C#, ASP.NET, Svelte, dan Laravel, serta mengelola database MySQL dan SQL Server untuk memastikan performa sistem yang stabil, cepat, dan efisien.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFokus \u0026amp; Keahlian\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eSaya senang memadukan antara pengembangan dan keamanan sistem. Bagi saya, aplikasi yang baik bukan hanya berfungsi dengan benar, tetapi juga \u003cstrong\u003eaman, terukur, dan mudah dipelihara.\u003c/strong\u003e\u003c/p\u003e","title":"Tentang Nuno Rigo Fadilah"}]