[{"content":"Ringkasan SSL/TLS merupakan fondasi keamanan komunikasi modern. Namun, dalam praktiknya masih banyak sistem yang mengalami masalah seperti sertifikat hampir kedaluwarsa, konfigurasi TLS lemah, atau informasi sertifikat yang tidak pernah diaudit secara rutin.\nPada artikel ini, saya akan membahas pembuatan SSL Checker \u0026amp; TLS Analyzer menggunakan Golang. Tools ini dirancang ringan, cepat, dan mudah diintegrasikan ke workflow DevOps maupun security automation.\nTools ini dapat digunakan untuk:\nMengecek masa berlaku sertifikat Menampilkan issuer \u0026amp; subject Validasi hostname Analisis TLS version \u0026amp; cipher suite Dasar penilaian keamanan SSL endpoint Repository:\nüîó https://github.com/NunoRifa/SSL-Checker-Golang\nApa yang akan Anda pelajari Setelah membaca artikel ini, Anda akan memahami:\nCara membangun SSL checker menggunakan Golang Pemanfaatan package crypto/tls dan crypto/x509 Cara membaca detail sertifikat SSL dari server Teknik validasi hostname \u0026amp; expiry certificate Dasar TLS inspection tanpa tools eksternal Artikel ini cocok untuk:\nSysadmin DevOps Engineer Security Engineer Backend Developer Pentester (untuk recon pasif \u0026amp; validasi konfigurasi) Gambaran Umum Tools Tools ini bekerja dengan cara:\nMembuat koneksi TLS ke target host Mengambil certificate chain dari server Mengekstrak informasi sertifikat Menampilkan hasil analisis dalam output terstruktur Pendekatan ini tidak melakukan eksploitasi dan sepenuhnya bersifat read-only inspection.\nFitur Utama Beberapa fitur utama dari SSL Checker berbasis Golang ini antara lain:\nüîê Certificate Inspection Common Name (CN) Subject Alternative Name (SAN) Issuer ‚è≥ Expiry Check Not Before Not After Sisa hari sebelum kedaluwarsa üåê Hostname Validation üîí TLS Version Detection üîë Cipher Suite Information ‚ö° Cepat \u0026amp; ringan (native Go binary) Persyaratan Sebelum menggunakan tools ini, pastikan Anda memiliki:\nGo 1.20+ (disarankan) Akses internet ke target domain Target domain menggunakan TLS Cara Menggunakan Clone repository:\ngit clone https://github.com/NunoRifa/SSL-Checker-Golang.git cd SSL-Checker-Golang Build binary:\ngo build -o ssl-checker Jalankan tools:\n./ssl-checker example.com:443 Atau tanpa port (default 443):\n./ssl-checker example.com Contoh Output Contoh output hasil eksekusi tools:\nHostname : example.com Issuer : Let\u0026#39;s Encrypt Valid From : 2025-01-01 Valid Until : 2025-04-01 Days Remaining : 54 TLS Version : TLS 1.3 Cipher Suite : TLS_AES_256_GCM_SHA384 Hostname Valid : true Output ini dapat dengan mudah diparsing untuk:\nAutomation script Monitoring system Integrasi CI/CD Alerting system Arsitektur Singkat Secara internal, tools ini memanfaatkan:\ntls.Dial untuk koneksi TLS ConnectionState() untuk membaca TLS metadata x509.Certificate untuk parsing sertifikat Keunggulan pendekatan ini:\nTidak membutuhkan OpenSSL Tidak memanggil tools eksternal Cross-platform (Linux, macOS, Windows) Keamanan \u0026amp; Etika Hal penting yang perlu diperhatikan:\nTools ini tidak melakukan scanning agresif Tidak mencoba exploit atau downgrade attack Aman digunakan untuk: Domain sendiri Infrastruktur internal Sistem yang Anda kelola secara legal Gunakan tools ini secara etis dan bertanggung jawab. Potensi Pengembangan Lanjutan Beberapa ide pengembangan selanjutnya:\nOutput format JSON SSL grading (A+ ‚Üí F) Deteksi TLS deprecated (TLS 1.0 / 1.1) Cipher strength analysis Integrasi Prometheus exporter Mode bulk domain check Exit code berbasis severity (CI/CD friendly) Penutup Dengan Golang, kita bisa membangun tools security yang ringan, cepat, dan portable tanpa ketergantungan eksternal. SSL Checker ini cocok sebagai fondasi untuk:\nMonitoring sertifikat Security baseline check Automation pipeline Tools sederhana seperti ini sering kali menjadi early warning system yang mencegah outage besar akibat sertifikat kedaluwarsa atau konfigurasi TLS yang lemah.\nSemoga artikel ini bermanfaat dan bisa menjadi referensi bagi Anda yang ingin membangun security tools berbasis Golang.\n","permalink":"https://nunorifa.my.id/posts/ssl-checker-dan-tls-analyzer-menggunakan-golang/","summary":"Tutorial dan pembahasan tools SSL Checker berbasis Golang untuk melakukan inspeksi sertifikat SSL/TLS: expiry, issuer, SAN, TLS version, cipher suite, hingga validasi keamanan dasar.","title":"SSL Checker \u0026 TLS Analyzer Menggunakan Golang"},{"content":"Ringkasan SSL/TLS certificate sering kali dianggap \u0026ldquo;pasang sekali lalu lupa\u0026rdquo;. Padahal, sertifikat yang kedaluwarsa, hostname mismatch, atau menggunakan protokol lama dapat menyebabkan downtime, error di browser, bahkan celah keamanan serius.\nPada artikel ini, saya akan membahas bagaimana membangun Advanced SSL Health Monitoring menggunakan n8n. Workflow ini tidak hanya mengecek masa berlaku sertifikat, tetapi juga:\nMenilai SSL grade Mendeteksi protokol TLS yang deprecated Mengidentifikasi kerentanan keamanan Memberikan alert bertingkat (low ‚Üí critical) ke Telegram Semua proses berjalan otomatis dan terjadwal tanpa perlu intervensi manual.\nCatatan: artikel ini ditujukan untuk pembelajaran dan praktik terbaik DevOps / security monitoring. Gunakan secara etis dan bertanggung jawab.\nSource code / workflow: github\nApa yang akan Anda pelajari Setelah membaca artikel ini, Anda akan memahami:\nCara menggunakan n8n sebagai security automation tool Teknik membaca daftar domain dari Data Table Integrasi API SSL Checker dan custom SSL assessment script Parsing output SSL scanner menggunakan Code Node Membuat logic alert berbasis severity Mengirim notifikasi Telegram otomatis Artikel ini cocok untuk:\nSysadmin DevOps Engineer Security Engineer Web administrator yang mengelola banyak domain Persiapan \u0026amp; Persyaratan Sebelum memulai, pastikan Anda sudah menyiapkan:\nn8n instance (self-hosted atau cloud) Telegram Bot Token \u0026amp; Chat ID Data Table n8n berisi daftar domain Minimal memiliki kolom:\ndomain --- example.com example.com:8443 Server dengan: Node.js Akses SSH dari n8n Script SSL assessment: sysadmin-toolkit/scripts/ssl/ssl-health-assessment.js Potongan arsitektur \u0026amp; alur kerja singkat Secara garis besar, workflow ini berjalan sebagai berikut:\nSchedule Trigger Menjalankan workflow setiap hari (contoh: jam 10 pagi) Get Row(s) - Data Table Mengambil daftar domain yang ingin dimonitor Split Host \u0026amp; Port Memisahkan domain dan port jika ada (example.com:8443) Check SSL (API) Mengambil data dasar SSL dari ssl-checker.io Expiry Check Jika sertifikat ‚â§ 7 hari ‚Üí kirim alert cepat Advanced SSL Assessment (SSH) Menjalankan script lokal untuk: SSL grade TLS version Vulnerabilities Rekomendasi keamanan Format Output Parsing JSON Menentukan severity alert Telegram Notification Mengirim alert terstruktur ke Telegram Contoh payload JSON hasil SSL assessment Output dari script SSL assessment diproses dalam format JSON, contoh sederhananya:\n{ \u0026#34;hostname\u0026#34;: \u0026#34;example.com\u0026#34;, \u0026#34;overallGrade\u0026#34;: \u0026#34;B\u0026#34;, \u0026#34;certificate\u0026#34;: { \u0026#34;issuer\u0026#34;: \u0026#34;Let\u0026#39;s Encrypt\u0026#34;, \u0026#34;daysUntilExpiry\u0026#34;: 12, \u0026#34;isValid\u0026#34;: true, \u0026#34;hostnameMatch\u0026#34;: true }, \u0026#34;protocols\u0026#34;: { \u0026#34;tls13\u0026#34;: true, \u0026#34;tls12\u0026#34;: true, \u0026#34;tls10\u0026#34;: false }, \u0026#34;vulnerabilities\u0026#34;: { \u0026#34;hasVulnerabilities\u0026#34;: false }, \u0026#34;recommendations\u0026#34;: [ \u0026#34;Disable TLS 1.0\u0026#34;, \u0026#34;Enable HSTS\u0026#34; ] } Data ini kemudian digunakan untuk menentukan apakah perlu alert atau tidak.\nKeamanan \u0026amp; Etika Beberapa hal penting yang perlu diperhatikan:\nMonitoring SSL tidak melakukan eksploitasi Semua pengecekan bersifat read-only Gunakan hanya untuk: Domain milik sendiri Domain yang Anda kelola secara legal Jangan gunakan workflow ini untuk scanning tanpa izin Security monitoring bertujuan mencegah masalah, bukan menciptakan masalah baru.\nContoh pesan alert Telegram Jika ditemukan masalah, bot akan mengirim pesan seperti berikut:\nüîê SSL Health Check: example.com ‚ö†Ô∏è SSL issues detected for example.com Grade: C | Expires in 12 days Issues found: ‚Ä¢ Poor SSL grade: C ‚Ä¢ Deprecated protocols enabled ‚Ä¢ Certificate expires in 12 days Untuk kasus critical, bot bisa memicu mention seperti @here agar segera diperhatikan.\nPotensi perbaikan \u0026amp; fitur lanjutan Workflow ini masih bisa dikembangkan lebih jauh, misalnya:\nIntegrasi Discord / Slack Export hasil scan ke Grafana / Prometheus Auto-create ticket Jira / GitLab Issue Tracking histori SSL grade per domain Auto reminder renewal + siapa PIC domain Monitoring cipher suite \u0026amp; OCSP stapling Penutup Dengan memanfaatkan n8n, kita bisa membangun sistem SSL Health Monitoring yang jauh lebih cerdas dibanding sekadar cek expiry manual. Pendekatan ini sangat membantu ketika Anda mengelola banyak domain dan ingin proaktif, bukan reaktif.\nAutomation bukan hanya soal efisiensi, tapi juga soal keamanan dan keandalan sistem.\nSemoga artikel ini bermanfaat dan bisa menjadi inspirasi untuk membangun security automation lainnya üöÄ Jika Anda tertarik, workflow ini bisa dengan mudah diperluas ke monitoring service lain seperti HTTP health, port scanning, atau certificate transparency.\n","permalink":"https://nunorifa.my.id/posts/advanced-ssl-health-monitoring-menggunakan-n8n/","summary":"Tutorial membangun workflow n8n untuk monitoring kesehatan SSL secara otomatis. Mulai dari pengecekan expiry sertifikat, penilaian SSL grade, deteksi protokol usang \u0026amp; vulnerability, hingga pengiriman notifikasi Telegram berbasis severity.","title":"Advanced SSL Health Monitoring Menggunakan n8n"},{"content":"Ringkasan Artikel ini merupakan sharing ilmu pribadi saya tentang bagaimana cara membuat dan mendokumentasikan Google Custom Search Engine (CSE) Dorking Tool menggunakan bahasa Python.\nTool ini berfungsi untuk mencari URL potensial berdasarkan pola dork tertentu melalui API resmi Google, memeriksa status HTTP tiap hasil, dan menyimpan output-nya dalam format teks dan JSON.\nTujuan saya menulis ini bukan untuk mendorong eksploitasi, melainkan untuk memperkenalkan bagaimana konsep reconnaissance automation bekerja dengan API publik, threading, dan parsing hasil pencarian.\nCatatan: Artikel ini untuk tujuan pembelajaran dan eksplorasi teknis. Jangan gunakan untuk menyerang, mengeksploitasi, atau mengakses sistem tanpa izin.\nApa yang akan Anda pelajari Struktur sederhana sebuah tool dorking berbasis Python. Cara menggunakan Google Custom Search API (CSE) untuk query otomatis. Proses pemeriksaan status HTTP secara paralel menggunakan ThreadPoolExecutor. Menyimpan hasil scanning ke file .txt dan .json. Cara membuat installer script sederhana agar tool mudah dijalankan di terminal. Praktik aman, etika, dan batas penggunaan API saat melakukan eksperimen. Persiapan \u0026amp; Persyaratan Pastikan Anda memiliki:\nPython 3.8+ Pip (package manager bawaan Python) Koneksi internet Google API Key dan CSE CX ID\n(dapat dibuat di Google Custom Search Engine) Terminal / Command Line Struktur proyek Berikut struktur folder yang saya gunakan:\ngoogle-cse-dorktool/ ‚îú‚îÄ‚îÄ dork_tool.py # Script utama tool dorking ‚îú‚îÄ‚îÄ install_dork_tool.sh # Script instalasi dan symlink CLI ‚îî‚îÄ‚îÄ README.md # Dokumentasi dan panduan penggunaan Penjelasan singkat dork_tool.py ‚Üí berisi logika utama (Google CSE request, parallel check, output formatter). install_dork_tool.sh ‚Üí script opsional untuk instalasi cepat ke sistem. README.md ‚Üí dokumentasi tool dan contoh penggunaan CLI. Contoh isi .env (opsional) Jika Anda ingin menyembunyikan API key dari kode sumber, buat file .env di root proyek seperti berikut:\nGOOGLE_API_KEY=\u0026#34;YOUR_GOOGLE_API_KEY\u0026#34; CSE_CX=\u0026#34;YOUR_CUSTOM_SEARCH_ENGINE_CX\u0026#34; Kemudian, Anda bisa membaca variabel ini di dork_tool.py dengan:\nimport os GOOGLE_API_KEY = os.getenv(\u0026#34;GOOGLE_API_KEY\u0026#34;) CSE_CX = os.getenv(\u0026#34;CSE_CX\u0026#34;) Potongan kode penting dari dork_tool.py Agar tidak terlalu panjang, saya tampilkan hanya bagian inti untuk pembelajaran:\n# Bagian inisialisasi dan request API CSE def google_cse_search(query, api_key, cse_cx, num_results=10): url = f\u0026#34;https://www.googleapis.com/customsearch/v1?q={query}\u0026amp;key={api_key}\u0026amp;cx={cse_cx}\u0026#34; response = requests.get(url) data = response.json() return [item[\u0026#34;link\u0026#34;] for item in data.get(\u0026#34;items\u0026#34;, [])] # Pemeriksaan status halaman secara paralel def check_status(url): try: r = requests.get(url, timeout=8, verify=False) return (url, r.status_code, len(r.content)) except Exception: return (url, None, 0) Potongan di atas sudah cukup untuk memahami flow dasar: ambil URL dari CSE, lalu cek responnya\nCara instalasi (menggunakan install_dork_tool.sh) File install_dork_tool.sh saya letakkan di root repository. Isinya membantu Anda menginstal dependency dan menambahkan symlink ke sistem agar bisa menjalankan tool langsung lewat terminal.\n#!/bin/bash # install_dork_tool.sh pip3 install --user requests beautifulsoup4 urllib3 chmod +x dork_tool.py sudo ln -sf $(pwd)/dork_tool.py /usr/local/bin/dorktool echo \u0026#34;Instalasi selesai. Jalankan: dorktool --help\u0026#34; Untuk menginstal:\nchmod +x install_dork_tool.sh ./install_dork_tool.sh Cara penggunaan (CLI) Setelah instalasi, Anda bisa menjalankan tool ini dengan berbagai argumen:\n# Menampilkan bantuan dorktool --help # Contoh mencari parameter ?id= di seluruh domain dorktool -u \u0026#34;?id=\u0026#34; -n 20 --google-api-key \u0026#34;YOUR_KEY\u0026#34; --cse-cx \u0026#34;YOUR_CX\u0026#34; # Contoh dengan domain spesifik dan output file dorktool -d \u0026#34;example.com\u0026#34; -u \u0026#34;?page=\u0026#34; -s 200 301 -n 50 -o result.txt --json Penjelasan singkat argumen:\n-d atau --domain ‚Üí filter domain target -u atau --url-pattern ‚Üí pola dork (?id=, ?page=, dsb.) -s ‚Üí status code filter -n ‚Üí jumlah hasil pencarian -o ‚Üí output file --google-api-key \u0026amp; --cse-cx ‚Üí kredensial API CSE Contoh hasil output Hasil IMG: Hasil TXT:\nURL: https://target.example/?id=123 Status Code: 200 Title: Example Page Content Length: 3245 bytes Final URL: https://target.example/?id=123 -------------------------------------------------- Keamanan \u0026amp; Etika Bagian ini sangat penting, saya tekankan kembali untuk pembaca:\nGunakan tool ini hanya pada sistem yang Anda miliki atau dengan izin tertulis. Jangan menyimpan API key di repo publik. Jangan mematikan SSL verification di lingkungan produksi. Tambahkan rate limit / delay agar tidak mengirim terlalu banyak request ke server target. Hargai kebijakan robots.txt setiap situs. Gunakan hasil pencarian hanya untuk pembelajaran, riset keamanan, atau uji internal. Disclaimer: Semua contoh dan kode pada artikel ini bersifat edukatif. Penulis tidak bertanggung jawab atas penyalahgunaan kode di luar konteks pembelajaran.\nPotensi pengembangan Bagi pembaca yang ingin melanjutkan eksperimen:\nMenambahkan fallback ke DuckDuckGo / Bing jika Google API limit tercapai. Menyimpan hasil scan ke database (mis. SQLite atau MongoDB). Menambahkan proxy rotation atau user-agent rotation otomatis. Mengimplementasikan rate limit berbasis domain. Menambahkan GUI sederhana (mis. tkinter / streamlit). Penutup Proyek ini saya tulis sebagai bentuk sharing ilmu mengenai teknik dorking automation secara legal dan etis. Diharapkan pembaca dapat memahami bagaimana integrasi API, threading, dan pengolahan hasil dilakukan di Python.\nJika Anda ingin mencoba atau berkontribusi, seluruh source code bisa dilihat di: Repository: github\n","permalink":"https://nunorifa.my.id/posts/google-cse-dorking-tool-web-surface-scanner/","summary":"Panduan praktis langkah-demi-langkah membangun dan menjalankan tool dorking berbasis Google Custom Search API. Pembaca akan belajar cara mengumpulkan URL dari CSE, memeriksa respons secara paralel, menyimpan hasil, serta menerapkan konfigurasi dan langkah keamanan untuk eksperimen yang bertanggung jawab.","title":"Google CSE Dorking Tool - Web Surface Scanner"},{"content":"Pendahuluan Menyiapkan workstation untuk penetration testing membutuhkan beberapa komponen inti: hypervisor/virtualizer yang stabil, image target yang realistis (mis. Windows), serta mesin serangan yang berisi tool pentest (mis. Kali Linux). Dokumen ini menyajikan tautan unduhan untuk beberapa komponen yang umum dipakai dalam lab pentesting pribadi‚Äîditujukan untuk mempercepat setup lab uji tanpa harus mengonfigurasi semuanya dari nol.\nCatatan penting: semua berkas dan image yang dibagikan di sini digunakan untuk tujuan pembelajaran dan pengujian pada lingkungan yang Anda miliki izin untuk menguji. Jangan gunakan image atau tools ini untuk aktivitas ilegal. Selalu pastikan Anda memiliki persetujuan eksplisit sebelum melakukan pengujian terhadap sistem pihak ketiga.\nDownload: VMware Workstation 17.5.2 (Windows x86-64) VMware Workstation adalah aplikasi virtualisasi yang memungkinkan menjalankan beberapa sistem operasi tamu (guest OS) di dalam satu host. Untuk keperluan pentesting, Workstation berguna untuk mengisolasi target dan environment serangan sehingga tidak mengganggu host utama.\nSumber unduhan:\nDownload dari ln5.sync.com - link 1 Download dari drive.google.com - link 2 Tips: setelah mengunduh, verifikasi checksum (jika tersedia) dan jalankan file di lingkungan terisolasi bila Anda ragu terhadap integritas berkas.\nDownload: Windows MSEdge‚ÄìWin10 (VM image) Image Windows MSEdge‚ÄìWin10 adalah mesin virtual Windows yang sudah dikonfigurasi cocok untuk mensimulasikan target Windows asli. Image prebuilt mempercepat pengujian exploit, kompatibilitas, maupun analisis forensik tanpa perlu memasang OS dari awal.\nSumber unduhan:\nDownload dari ln5.sync.com - link 1 Download dari drive.google.com - link 2 Perhatian: Pastikan lisensi dan ketentuan penggunaan image tersebut sesuai. Untuk pengujian yang lebih aman dan terjamin update, pertimbangkan menggunakan image resmi Microsoft yang disediakan untuk pengembang/pengetesan.\nDownload: Metasploitable (Lab Target Rentan) Metasploitable adalah VM yang sengaja dirancang rentan untuk keperluan latihan. Sangat cocok untuk belajar exploitasi, konfigurasi Metasploit, serta menguji teknik hardening setelah eksploitasi.\nSumber unduhan:\nDownload dari sourceforge.net- link 1 Catatan: gunakan Metasploitable hanya di jaringan terisolasi. Jangan sambungkan VM rentan ke jaringan produksi.\n(Opsional) Kali Linux - versi custom dari ZSecurity Kali Linux adalah distribusi standar untuk penetration testing, berisi banyak alat populer (nmap, Metasploit, John, dll.). Ada versi yang dimodifikasi oleh pihak ketiga seperti ZSecurity yang menyediakan image dengan konfigurasi dan paket tambahan untuk kemudahan setup.\nSumber unduhan:\nDownload Kali Linux Patched ZSecurity Rekomendasi: bila Anda mengutamakan keamanan dan update, gunakan versi resmi Kali dari kali.org. Gunakan image custom hanya jika Anda mempercayai sumber dan memahami perubahan yang dilakukan.\nPenutup Dokumen ini dirancang untuk membantu Anda mempercepat pembuatan lab pentest, mulai dari hypervisor (VMware Workstation), image target Windows, hingga mesin latihan rentan (Metasploitable) dan opsi Kali Linux. Gunakan tautan dengan bijak, dan selalu prioritaskan keamanan serta etika dalam setiap pengujian.\n","permalink":"https://nunorifa.my.id/posts/setup-tools-penetration-testing/","summary":"Dokumen ini adalah panduan praktis untuk menyiapkan workstation pentesting. Pembaca diberikan dua sumber unduhan untuk VMware Workstation 17.5.2 (link Sync dan Google Drive) dan dua sumber untuk image Windows MSEdge‚ÄìWin10 yang siap dipakai pada VMware. Sebagai tambahan terdapat opsi untuk mengunduh Kali Linux yang telah dimodifikasi dari ZSecurity.","title":"Setup Tools Penetration Testing"},{"content":"Saya Nuno Rigo Fadilah, juga dikenal sebagai Nuno Rifa. Saya seorang Web Developer yang memiliki ketertarikan kuat pada dunia sistem dan keamanan siber.\nSelama beberapa tahun terakhir, saya membangun aplikasi berbasis web menggunakan C#, ASP.NET, Svelte, dan Laravel, serta mengelola database MySQL dan SQL Server untuk memastikan performa sistem yang stabil, cepat, dan efisien.\nFokus \u0026amp; Keahlian\nSaya senang memadukan antara pengembangan dan keamanan sistem. Bagi saya, aplikasi yang baik bukan hanya berfungsi dengan benar, tetapi juga aman, terukur, dan mudah dipelihara.\nBeberapa bidang yang saya kuasai:\nPengembangan aplikasi web (Frontend \u0026amp; Backend) Optimasi query Automasi dan scripting Dasar-dasar keamanan siber dan penetration testing Perjalanan Saat Ini\nSaat ini, saya sedang mendalami bidang Cybersecurity dan Penetration Testing untuk memperluas wawasan saya di dunia keamanan informasi.\nTujuan saya adalah bertransisi menjadi seorang Cybersecurity Specialist atau Pentester yang mampu melihat sistem tidak hanya dari sisi pengembang, tetapi juga dari sisi keamanan.\n","permalink":"https://nunorifa.my.id/about/","summary":"\u003cp\u003eSaya \u003cstrong\u003eNuno Rigo Fadilah\u003c/strong\u003e, juga dikenal sebagai \u003cstrong\u003eNuno Rifa\u003c/strong\u003e. Saya seorang Web Developer yang memiliki ketertarikan kuat pada dunia sistem dan keamanan siber.\u003c/p\u003e\n\u003cp\u003eSelama beberapa tahun terakhir, saya membangun aplikasi berbasis web menggunakan C#, ASP.NET, Svelte, dan Laravel, serta mengelola database MySQL dan SQL Server untuk memastikan performa sistem yang stabil, cepat, dan efisien.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFokus \u0026amp; Keahlian\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eSaya senang memadukan antara pengembangan dan keamanan sistem. Bagi saya, aplikasi yang baik bukan hanya berfungsi dengan benar, tetapi juga \u003cstrong\u003eaman, terukur, dan mudah dipelihara.\u003c/strong\u003e\u003c/p\u003e","title":"Tentang Nuno Rigo Fadilah (Nuno Rifa)"},{"content":"Ringkasan Artikel ini menjelaskan cara membuat server sederhana menggunakan Golang yang menampilkan halaman landing sementara, meminta izin kamera dari pengguna (depan / belakang), menangkap foto, mengirim foto (base64 ‚Üí bytes) dan data lokasi (diperoleh dari IP publik) ke Telegram. Setelah pengiriman selesai, pengguna diarahkan ke URL tujuan yang awalnya diberikan melalui query parameter ?url=.\nCatatan: artikel ini untuk tujuan pembelajaran / eksperimen. Jangan gunakan untuk melanggar privasi atau hukum.\nSource code: github\nApa yang akan Anda pelajari Struktur aplikasi backend Golang yang melayani HTML + JavaScript. Cara meminta akses kamera di browser, menangkap gambar, dan mengirimkannya sebagai JSON. Mengubah data data:image/jpeg;base64,... menjadi byte di server Go. Mengambil IP publik dan melakukan lookup lokasi menggunakan IP2Location API. Mengirim pesan dan foto ke Telegram melalui Bot API. Contoh konfigurasi .env untuk menyimpan token rahasia. Persiapan \u0026amp; Persyaratan Pastikan Anda memiliki:\nGo (disarankan 1.18+) Koneksi internet Akun Telegram + Bot (token dari BotFather) API key IP2Location Editor teks / terminal Struktur proyek (sederhana) camera-capture-server/ ‚îú‚îÄ‚îÄ main.go ‚îú‚îÄ‚îÄ .env ‚îî‚îÄ‚îÄ README.md Contoh isi .env botToken = \u0026#34;YOUR_BOT_TOKEN\u0026#34; chatID = \u0026#34;YOUT_BOT_CHAT_ID\u0026#34; ip2LocationToken = \u0026#34;YOUR_API_IP2LOCATION\u0026#34; botToken = token Bot Telegram chatID = ID chat (user atau grup) tujuan pesan ip2LocationToken = API key IP2Location Potongan arsitektur \u0026amp; alur kerja singkat Pengguna mengunjungi: http://localhost:8080/?url=https://example.com Server menyajikan halaman HTML yang menjalankan JavaScript: Meminta izin kamera (mencoba front lalu back). Mengambil snapshot ke canvas ‚Üí toDataURL('image/jpeg', 0.8). Mengirim JSON POST ke /upload-photo berisi: image, userId, urlId, camera, message. Server Go menerima JSON: Mengambil IP publik dengan https://api.ipify.org/?format=json. Memanggil IP2Location: https://api.ip2location.io/?key=TOKEN\u0026amp;ip=IP. Men-decode base64 image menjadi []byte. Menyusun pesan teks berisi IP, lokasi, Google Maps link, dan info ASN. Mengirim pesan teks dan foto ke Telegram via sendMessageToTelegram \u0026amp; sendPhotoToTelegram. Setelah selesai, browser diarahkan ke URL tujuan (url query param). Contoh payload JSON dari browser { \u0026#34;image\u0026#34;: \u0026#34;data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD...\u0026#34;, \u0026#34;userId\u0026#34;: \u0026#34;123456789\u0026#34;, \u0026#34;urlId\u0026#34;: \u0026#34;https://example.com\u0026#34;, \u0026#34;camera\u0026#34;: \u0026#34;front\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Foto berhasil diambil.\u0026#34; } Keamanan \u0026amp; Etika Jangan jalankan server ini dalam lingkungan produksi tanpa penambahan kontrol akses, enkripsi transport (HTTPS), dan kebijakan privasi yang jelas. Selalu minta izin eksplisit dari pengguna sebelum mengakses kamera. Batasi penggunaan data, simpanan, dan akses bot Telegram agar tidak bocor. Gunakan hanya untuk eksperimen yang legal dan etis. Contoh pesan yang dikirim ke Telegram Pesan teks yang dikirim berisi:\nIP publik URL asal (From URL) URL host (link yang mengarah kembali ke server dengan query ?url=...) Info lokasi: country, region, city, latitude, longitude Link Google Maps untuk koordinat AS/ISP, dan flag Is Proxy Contoh format (tekstual):\nIP Address : 103.123.45.67 From URL : https://example.com URL Host : http://yourserver.com/?url=https://example.com Location Country Code: ID Country Name: Indonesia Region Name : Jawa Timur City Name : Surabaya Latitude : -7.2575 Longitude : 112.7521 Maps : https://www.google.co.id/maps/place/-7.2575,112.7521 Network AS/ISP : PT Telkom Indonesia Is Proxy : false Foto akan diunggah sebagai file user_photo.jpg ke chat Telegram tujuan.\nPotensi perbaikan \u0026amp; fitur lanjutan Tambahkan HTTPS (TLS) agar komunikasi aman. Buat autentikasi / token validasi untuk endpoint /upload-photo agar tidak sembarang pihak bisa POST. Simpan foto ke cloud storage (S3, GCS) atau database dengan retention policy. Batasi resolusi dan ukuran upload untuk efisiensi. Tampilkan fallback dan pemberitahuan bila kamera tidak tersedia. Penutup Proyek ini merupakan contoh praktis integrasi frontend-browser (akses kamera) dengan backend Golang serta layanan pihak ketiga (IP2Location dan Telegram Bot). Cocok sebagai eksperimen untuk memahami alur data (media + metadata) dari klien ke server dan integrasi API.\n","permalink":"https://nunorifa.my.id/posts/membangun-server-capture-kamera-dan-redirect-otomatis-menggunakan-golang/","summary":"Langkah demi langkah membuat server Golang yang mengambil foto pengguna lewat browser, mengonversi gambar base64, mengambil IP publik \u0026amp; lokasi via IP2Location, lalu mengirimkan foto dan data lokasi ke Telegram Bot. Termasuk contoh konfigurasi .env dan instruksi menjalankan server.","title":"Membangun Server Capture Kamera dan Redirect Otomatis Menggunakan Golang"},{"content":"Ringkasan Artikel ini membahas pembuatan Samarinda Token Generator, sebuah script Python yang secara otomatis mengambil token dari situs https://generatetoken.my.id/samarinda/.\nTool ini bekerja dengan mengirimkan HWID (Hardware ID) ke server menggunakan metode POST, lalu mengekstrak token hasil dari respon HTML menggunakan regex, tanpa perlu membuka browser.\nSource code: github\nApa yang akan Anda pelajari Cara membuat script otomatisasi HTTP POST dengan Python. Penggunaan library requests dan urllib3 untuk komunikasi web. Teknik regex parsing untuk mengekstrak data dari HTML. Menyalin hasil token langsung ke clipboard menggunakan pyperclip. Penanganan error jaringan dengan try-except. Persiapan \u0026amp; Persyaratan Pastikan Anda sudah menyiapkan:\nPython 3.x Modul berikut: pip install requests urllib3 pyperclip Koneksi internet aktif HWID valid (32 karakter hex) Struktur proyek samarinda-token-generator/ ‚îú‚îÄ‚îÄ NewKeyGen.py ‚îî‚îÄ‚îÄ README.md Penjelasan Alur Program Input HWID Pengguna diminta memasukkan HWID (32 karakter hex) melalui input terminal. hwid = input(\u0026#34;Masukkan Licensed Key (hex 32 karakter): \u0026#34;).strip() Kirim Request POST Script membuat sesi HTTP dan mengirim permintaan POST ke: https://generatetoken.my.id/samarinda/ dengan payload:\ndata = {\u0026#39;hwid\u0026#39;: hwid, \u0026#39;generate_token\u0026#39;: \u0026#39;\u0026#39;} Parsing Token Respon HTML dari server mengandung potongan teks: html: \u0026#34;\u0026lt;p id=\u0026#39;generated-token\u0026#39;\u0026gt;SMD-OL1HRD7JB2\u0026lt;/p\u0026gt;\u0026#34; Token diekstrak menggunakan regex:\nmatch = re.search(r\u0026#34;html:\\s*\\\u0026#34;\u0026lt;p id=\u0026#39;generated-token\u0026#39;\u0026gt;(.*?)\u0026lt;/p\u0026gt;\\\u0026#34;\u0026#34;, response.text) Salin ke Clipboard Jika token ditemukan, hasil langsung disalin ke clipboard: pyperclip.copy(token) print(\u0026#34;Token telah disalin ke clipboard.\u0026#34;) Penanganan Error Jika server gagal diakses, script akan menampilkan pesan error dari requests.exceptions.RequestException. Contoh Output Terminal Masukkan Licensed Key (hex 32 karakter): AE9EEB8ACEBAC3808006F786543210AJ ==== Mencari token ==== Token ditemukan: SMD-OL1HRD7JB2 Token telah disalin ke clipboard. Tekan sembarang tombol untuk keluar... Cuplikan Kode Utama match = re.search(r\u0026#34;html:\\s*\\\u0026#34;\u0026lt;p id=\u0026#39;generated-token\u0026#39;\u0026gt;(.*?)\u0026lt;/p\u0026gt;\\\u0026#34;\u0026#34;, response.text) if match: token = match.group(1) print(\u0026#34;Token ditemukan:\u0026#34;, token) return token else: print(\u0026#34;Token tidak ditemukan.\u0026#34;) Catatan Teknis Script ini tidak menggunakan Selenium atau JavaScript engine - cukup dengan parsing teks HTML dari respon. Header request diatur sedemikian rupa agar menyerupai browser sungguhan. Penggunaan verify=False menonaktifkan verifikasi SSL untuk mencegah error pada situs self-signed (tidak disarankan untuk produksi). Dapat dijalankan langsung di terminal Windows (menggunakan msvcrt.getch() untuk menunggu tombol keluar). Keamanan \u0026amp; Etika Jangan gunakan script ini untuk melakukan scraping atau request berulang yang dapat membebani server target. Gunakan hanya untuk eksperimen dan pembelajaran. Hindari menyebarkan token yang dihasilkan tanpa izin. Pastikan Anda memahami batas etika dan hukum dalam mengakses sistem pihak lain. Penutup Proyek ini adalah contoh praktis bagaimana Python dapat digunakan untuk mengotomatiskan interaksi web sederhana - dari mengirim form, membaca respon HTML, hingga menyalin hasil ke clipboard. Cocok untuk mempelajari dasar komunikasi client-server, parsing HTML ringan, dan struktur script utilitas berbasis CLI.\n","permalink":"https://nunorifa.my.id/posts/membangun-samarinda-token-generator-menggunakan-python/","summary":"Panduan membuat tool sederhana di Python yang mengirim permintaan POST ke server, memproses respon HTML yang berisi token, lalu menyalin hasil token ke clipboard. Cocok untuk pembelajaran automasi request‚Äìresponse dan parsing data dari web.","title":"Membangun Samarinda Token Generator Menggunakan Python"}]